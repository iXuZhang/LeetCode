intersection


1.两个数组找intersection
我先用set做 他问了复杂度
然后说重复的也要算上怎么办，我换成了map 他问了复杂度. 1point3acres.com/bbs
然后说拍好序的怎么做，我用循环做了一遍
然后说没排序，要先排序怎么快一点， 我说范围不大的话桶排就是了   又尼玛做了一遍

然后不让我写代码了， 估计时间不大够
说范围很大， 我说那桶排不合适了啊。。。  我说想用heap  他说可以   又问复杂度

然后又问我这个应该怎么测试， 我说了需要测试的一些情况


说了一下如果元素重复，发现我没考虑，赶紧加上。说了如果数组为空，忘记说如果是Null
用 hashmap！！！

两个数组里找相同ID（duplicate问题）

找两个array的intersection，然后怎么处理有duplicate的情况

2.给两个set，返回一个SET包含第一个SET里第二个没有的 和第二个SET里第一个没有的。



3.ABC是三个sorted array，求共同出现的元素


4.给定三个集合，找出三个集合的重合。

4.题目是有一个网站，比如amazon.com，用户访问以后会记录用户的信息，
存在文件中，然后给两个文件代表不同的日期，要找出两天都访问过该网站的用户。
这个时候没啥想法，也没想到啥算法，就直接开始写读入文件的代码，然后小哥说别那么复杂，
输入直接是string array就行了。。。。所以题目就变成了2个string数组找相同的元素了。。。
然后我就写了一个用set的方法，把一个array里的元素放到hashset里，遍历另外一个数组，把caontain的元素加到List里最后输出list。。


5.问个数组里找duplicate,地里有这题，给定[0,n-1]范围的数放到size = n的数组里，看有没有重复

第一题，找数组中重复出现奇数次的元素，假定其他元素都重复偶数次。
然后followup，现在说可能有多个奇数次元素。

6.第一题，给一个lists，lists里面有n个list，list里面是一些String，找出这样的String：
在n个list里面都存在。. 鐗涗汉浜戦泦,涓€浜╀笁鍒嗗湴
找出来以后，把结果排序输出。。。
这题比较tricky，很多难以想象的条件。。。。
比如, 如果用map，你需要克服这种情况
a,a
a,
a
这种要忽略掉第一行两个a，最后只输出一个a


但是这种情况你也要考虑到
a,a,a. from: 1point3acres.com/bbs 
a,a,a 
a,a,a
这种是要输出3个a的

7.第一个是给两个数组，找两个数组公共的元素，然后不断展开问了hashmap的原理，
怎么解决冲突了，这个老生常谈的要记得滚瓜烂熟才行啊亲～
最后的follow up问了，现在用hashmap空间复杂度太高了，如果只给O（1）的空间怎么办，然后我就说那可以把两个数组排排序阿，
这样就可以使用到排序的良好特性了哟，然后他又展开了，问要排序你会选什么排序算法，我说快速排序，他说为啥用快速排序，然后我脑子一懵，说因为quicksort。。很quick，然后这个印度小哥就被乐得不行了,
快速排序是原地排序所以只要o（1）的空间阿，感觉达到点子上了，然后小哥问排完序之后具体怎么找intersection，
然后我就说用两个指针不断移动，遇到相同的就加到结果里，我就写了两个数组 12345 和23456 口头模拟了下，然后小哥就说right，然后立马就ok了.

两个数组找重复元素，我用hashset做的，他说你这个时间已经最优了，看看有没有其它方法，我又说了两个（两个排序，一个排序）
然后设计测试用例. 鐣欏鐢宠璁哄潧-涓€浜╀笁鍒嗗湴


8.这道题还跟duplicates有关，写一个method，parameters是一个array还有它的长度，返回有没有duplicates“。
由于不让用C++ STL，我说可以先排序然后比较相邻的。“怎么排序”。我说快排，mergesort, heapsort都行。“复杂度多少”。我说nlgn。
“还是太慢，有没有更好的方法”。我说可以用hashtable,这样就是O(n)了。“不许用hashtable". 
然后我说假设array中每个元素不是很大的话，我可以写一个direct-address table."。
然后我使劲一看，他给的method上面居然写着0 < arr[i] <= length for all 0 <= i < length.
然后我就写了direct-address的方法。“空间是多少”。我说O(n). 
“可不可以少用点内存”。我说用bitset。“怎么set还有test一个bit”。
我就给他讲了bit manipulation。“现在空间多少”。我说n/32. 
面试官说答得不错，表示很满意。
然后又问可不可以不用额外空间,注意这些数都是正数,用原数组来节省空间，由于都是positive number，可以取negative来标示该index的数是不是已经出现过。

9.
一个array 数字乱七八糟，但是每个数都出现两次，只有一个一次，找出幸运儿！
  我先说了个需要额外array的办法，他叫我不要额外array呢？那咱排序，再遍历。他又说能不能不遍历？傻眼了……这么多follow up，最后他提示了我两次我才想到二分法

他给了一个api，大概是用来读入两个file的，然后找到sharelist


